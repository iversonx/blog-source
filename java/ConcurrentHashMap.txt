ConcurrentHashMap主要设计目标是在减少更新竞争的同时保持并发可读性。第二个目标是保持与HashMap相同或更换的空间消耗，并支持多线程在空表上执行高初始插入率。

ConcurrentHashMap通常用作 binned (bucketed)哈希表。每个键值映射都保存在节点中。

大多数节点是具有散列，键，值和下一个字段的基本Node类的实例。但是，存在各种子类：TreeNodes排列在平衡树中，而不是lists。

TreeBins拥有TreeNodes集的根。在调整大小期间，ForwardingNodes被放置在箱柜的头部。ReservationIodes用作占位符，同时在computeIfAbsent和相关方法中建立值。

TreeBin，ForwardingNode和ReservationNode类型不包含普通用户键，值或哈希值，并且在搜索等期间很容易区分，因为它们具有负哈希字段以及空键和值字段。(这些特殊节点要么不常见，要么是瞬态的，因此携带一些未使用的字段的影响是微不足道的。)


第一次插入时，表被延迟地初始化为两倍大小的幂。表中的每个bin通常包含一个节点列表（最常见的是，列表只有零个或一个节点）。表中的每个bin通常包含一个节点列表（最常见的是，列表只有零个或一个节点）。表访问需要volatile/atomic读取，写入和CASes。因为没有其他方法可以在不添加更多间接指令的情况下安排此操作，所以我们使用内部（sun.misc.unsafe）操作。

我们使用节点散列字段的顶部（符号）位进行控制――由于寻址约束，它仍然可用。具有负哈希字段的节点在映射方法中被特殊处理或忽略。

第一个节点在空箱中的插入（通过put或其变体）通过将其CAS化到箱中来执行。

到目前为止，这是大多数键/哈希分布下的put操作的最常见情况。其他更新操作（插入，删除和替换）需要锁定。

我们不想浪费将不同的锁对象与每个bin关联所需的空间，因此使用bin列表本身的第一个节点作为锁。对这些锁的锁定支持依赖于内置的“同步”监视器。

但是，将列表的第一个节点用作锁本身还不够：当一个节点被锁定时，任何更新都必须首先验证它在锁定后仍然是第一个节点，如果不是，则重试。因为新节点总是附加到列表中，所以一旦节点位于bin的第一个位置，它将保持在第一个位置，直到删除或bin失效（在调整大小时）。

每个bin锁的主要缺点是，由同一个锁保护的bin列表中的其他节点上的其他更新操作可能会停止，例如当用户equals（）或映射函数需要很长时间时。

在随机哈希下，访问不同元素的两个线程的锁争用概率大约是1 /（8 * #elements）。

在实践中遇到的实际哈希码分布有时会明显偏离均匀随机性。
这包括当N>（1 << 30）时的情况，因此一些键必须发生碰撞。
类似地，在一些愚蠢或恶意的用法中，多个键被设计为具有相同的哈希码，或者只有在屏蔽的高位上不同的哈希码。
因此，当一个bin中的节点数量超过阈值时，我们使用一个辅助策略。
这些TreeBins使用一个平衡树来保存节点(红黑树的一种特殊形式)，将搜索时间限制到O(log N)。
TreeBins中的每个搜索步骤至少是常规列表中的两倍，但是假设N不能超过(1 << 64)

TreeBin中的每个搜索步骤至少是常规列表中的两倍，但是假设N不能超过（1 << 64）（在用完地址之前），则此边界搜索步骤，锁定保持时间等合理 常量（每个操作最坏情况下检查大约100个节点）只要键是可比较的（这是非常常见的 - 字符串，长整数等）。

TreeBin节点（TreeNodes）也保持与常规节点相同的“下一个”遍历指针，因此可以以相同的方式遍历迭代器。