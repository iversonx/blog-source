---
title: 结构型模式--代理模式
date: 2018-10-26
categories: 设计模式
tags: 学习笔记
description: 
---

#### 一、什么是代理模式

##### 定义

为其他对象提供一种代理以控制对这个对象的访问。

##### 结构和说明

[示意图]

- Proxy：代理对象，实现与具体的目标对象一样的接口，这样就可以使用代理来代替具体的目标对象。保存一个指向具体目标对象的引用，可以在需要的时候调用具体的目标对象。

- Subject：目标接口，定义代理和具体目标对象的接口，这样就可以在任何使用具体目标对象的地方使用代理对象。

- RealSubject：具体的目标对象。

##### 示例代码

```java
public interface Subject {
    // 示意方法
    public void request();
}

public class RealSubject implements Subject {
    public void request() {
        // 执行具体的功能处理
    }
}

public class Proxy implements Subject {
    private Subject realSubject;
    public Proxy(Subject realSubject) {
        this.realSubject = realSubject;
    }

    public void request() {
        // 转调具体的目标对象前，执行一些操作

        // 转调具体的目标对象
        realSubject.request();
        // 转调具体的目标对象后，执行一些操作
    }
}
```

#### 二、代理模式的一些细节

##### 代理模式的功能

代理模式是通过创建一个代理对象，用这个代理对象去代表真实的对象。当客户端操作代理对象时，实际上功能最终还是会由真实的对象来完成。

##### 代理的分类

- 虚代理：根据需要来创建开销很大的对象，该对象只有在需要的时候才会被真正创建。

- 远程代理：用来在不同的地址空间上代表同一个对象，这个不同的地址空间可以是在本机，也可以在其他机器上。在Java里面最典型的就是RMI技术。

- copy-on-write代理：在客户端操作时，只有对象确实改变了，才会真的拷贝一个目标对象。

- 保护代理：控制对原始对象的访问，如果需要，可以给不同的用户提供不同的访问权限，以控制它们对原始对象的访问。

- 缓存代理：为那些昂贵操作的接口提供临时的存储空间，以便多个客户端可以共享这些结果。

- 防火墙代理：保护对象不被恶意用户访问和操作。

- 同步代理：使多个用户能够同时访问目标对象而没有冲突。

- 智能指引：在访问对象时执行一些附加操作，如引用计数、第一次引用一个持久对象时，将它装入内存。

##### 具体目标和代理的关系

从代理模式的结构上看，似乎是一个具体目标对应一个代理，其实不是这样的。如果代理类能完全通过接口来操作它所代理的目标对象，那么代理对象就不需要指导具体目标，也就无须为每一个目标创建一个代理。

如果代理类必须要实例化它代理的目标对象，那么代理类就要指导具体目标对象，这样一个具体目标就会有一个代理类。

##### Java中的代理

Java对代理模式提供了内建的支持，在`java.lang.reflect`包下面，提供了一个Proxy的类和一个InvocationHandler的接口。通常使用Java内建的代理功能实现的代理称为动态代理。

Java的动态代理目前只能代理接口，基本的实现是依靠Java的反射极致和动态生成class的技术，来动态生成被代理的接口的实现对象。

##### 代理模式的本质

代理模式的本质是控制对象访问。代理模式通过代理目标对象，把代理对象插入到客户和目标对象之间，从而为客户和目标对象引入一定的间接性。这个间接性给了代理对象很多的活动空间。代理对象可以在调用具体目标对象前后，做些附加操作，从而实现新的功能或扩展目标对象的功能。

从实现上看，代理模式主要是使用对象的组合和委托，也可以采用对象继承的方式来实现代理，这种方式在某些情况下，比使用对象组合还要简单。

#### 三、何时选用代理模式

- 需要为一个对象在不同的地址空间提供局部代表时，可以使用远程代理。

- 需要按照需要创建开销很大的对象时，可使用虚代理。

- 需要控制对象原始对象的访问时，可以使用保护代理。

- 需要在访问对象执行一些附加操作时，可以使用只能指引代理。

#### 四、相关模式

- 代理模式和适配器模式

  这两个模式相似之处在于它们都为另一个对象提供间接性的访问，而且都是从自身以外的一个接口向这个对象转发请求。但从功能上，两个模式时不一样的。适配器模式主要用来解决接口之间不匹配的问题，通常时为所适配的对象提供不同的接口；而代理模式会实现和目标对象相同的接口。

- 代理模式和装饰模式

  相同之处是都在转调其他对象的前后执行一定的功能；不同的时候，装饰模式是为了不生成子类就可以给对象添加职责，也就是为了动态地增加功能；而代理模式的主要目的时控制对对象的访问。

#### 五、总结

- 代理模式的目的为了控制对对象的访问，通过增加一个代理对象来实现和具体目标相同的接口，这样可以代表具体目标，给客户端使用，从而可以控制客户端对具体目标对象的访问。

- 通常我们自己编写的代理模式成为静态代理，这种实现方式有个缺点是如果目标接口发生改变，那么代理类和具体目标实现都要变化；通常把使用Java反射实现的代理模式称为动态代理。Java动态代理目前只能代理接口，如果要实现类的代理，可以使用cglib。
