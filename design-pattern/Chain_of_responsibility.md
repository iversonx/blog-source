---
title: 职责链模式(Chain of Responsibility)
date: 2018-10-26
categories: 设计模式
tags: 学习笔记
description: 
---
#### 一、什么是职责链模式
##### 1. 定义
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

首先职责链模式会定义一个所有处理请求的对象都要继承实现的接口或抽象类，这样就有利于随时切换新的实现；其次每个处理请求对象只实现业务流程中的一步业务处理，这样使其变得简单；最后职责链模式会动态地来组合这些处理请求的对象，把它们按照流程动态地组合起来，并要求它们依次调用，这样就动态地实现了流程。

###### 职责链模式的本质是分离职责，动态组合。
分离职责是前提，只有先把复杂的功能分开，拆分成很多的步骤和小的功能处理，然后才能合理规划和定义职责类。

动态组合才是职责链模式的精华所在，因为要实现请求对象和处理对象的解耦，请求对象不知道谁才是真正的处理对象，因此要动态地把可能的处理对象组合起来。


##### 2. 结构说明
[结构示意图]

- Handler：定义职责的接口，通常在这里定义处理请求的方法，可以在这里实现后继链。
- ConcreteHandler：实现职责的类，在这个类中，实现对在它职责范围内请求的处理，如果不处理，就继续转发请求给后继者。
- Client：职责链的客户端，向链上的具体处理对象提交请求，让职责链负责处理。

##### 3. 示例代码
```java
public abstract class Handler {
    protected Handler successor;

    public void setSuccessor(Handler successor) {
        this.successor = successor;
    }

    public abstract void handleRequest();

}

public class ConcreteHandlerA extends Handler {

    @Override
    public void handleRequest() {
        // 这里只是示意
        boolean someCondition = false;
        if(someCondition) {
            // 如果属于自己处理的职责范围，就在这里处理请求
        } else {
            // 否则转发给后继对象或结束
            if(this.successor != null) {
                this.successor.handleRequest();
            }
        }
    }
}

public class ConcreteHandlerB extends Handler {

    @Override
    public void handleRequest() {
        // 这里只是示意
        boolean someCondition = false;
        if(someCondition) {
            // 如果属于自己处理的职责范围，就在这里处理请求
        } else {
            // 否则转发给后继对象或结束
            if(this.successor != null) {
                this.successor.handleRequest();
            }
        }
    }
}

public class Client {
    public static void main(String[] args) {
        Handler h1 = new ConcreteHandlerA();
        Handler h2 = new ConcreteHandlerB();
        h1.setSuccessor(h2);

        h1.handleRequest();
    }
}
```

职责链模式主要用来处理“客户端发出一个请求，有多个对象都有机会处理这个请求，但是客户端不知道究竟谁会来处理他的请求”的这样的情况。也就是需要让请求者和接收者解耦，这样就可以动态地切换和组合接收者。

##### 4. 如何构建链
职责链的链怎么构建，大致有以下一些方式：
- 可以实现在客户端提交请求前组合链。也就是在使用的时候动态组合链，称为外部链；
- 也可以在Handler里面实现链的组合，算是内部链的一种；
- 当然还有一种就是在各个职责对象中，由它们自行决定后续的处理对象。这种实现方式要求每个职责对象必须了解整个业务流程。

##### 5. 请求一定会被处理吗？
在职责链模式中，请求不一定会被处理，因为可能没有合适的处理者，请求在职责链中从头传递到尾，每个处理对象都判断不属于自己处理，最后请求就没有对象来处理。

可以在职责链的末端加上一个不支持此功能处理的职责对象，这样如果传递到这里，就会出现提示。

##### 6. 处理多种请求

###### 1. 简单的处理方式
为每种业务单独定义一个方法，然后客户端根据不同的需要调用不同的方法。

这种方式有个问题，就是只有增加一个业务，就需要修改职责接口，这样很不灵活。那有没有什么好方法来实现呢？分析一下现在变化的东西。

- 不同的业务需要传递的业务数据不同；
- 不同的业务请求方法不同；
- 不同的职责对象处理这些不同的业务请求的业务逻辑不同。

###### 2. 通用请求的处理方式
首先定义一套通用的调用框架，用一个通用的请求对象来封装请求传递的参数；然后定一个通用的调用方法，这个方法不区分具体业务，所有的业务都是这个方法，通过通用的请求对象中的业务标记进行区分；到了职责对象中，符合处理范围就和原来一样处理请求，否则传递到下一个处理对象。


#### 二、职责链模式的优缺点
##### 优点
- 请求者和接收者松散耦合
- 动态组合职责：职责链模式会把功能处理分散到单独的职责对象中，然后在使用的时候，可以动态组合职责形成职责链，从而可以灵活地给对象分配职责，也可以灵活地实现和改变对象的职责。


##### 缺点
- 产生很多细粒度对象
- 请求不一定能被处理

#### 三、何时选用职责链模式
- 如果有多个对象可以处理同一个请求，但是具体由哪个对象来处理该请求，是运行时刻动态确定的。可以使用职责链模式。
- 如果你想在不明确指定接收者的情况下，向多个对象中的其中一个提交请求的话，可以使用职责链模式。
- 如果想要动态指定处理一个请求的对象集合，可以使用职责链模式。

