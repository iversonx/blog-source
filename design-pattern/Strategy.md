---
title: 策略模式(Strategy)
date: 2018-10-26
categories: 设计模式
tags: 学习笔记
description: 
---
#### 一、什么是策略模式
##### 1. 定义
定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。策略模式使算法可独立于使用它的客户而变化。

##### 2. 结构说明
[结构示例图]

- Strategy：策略接口，用来约束一系列具体的策略算法。Context使用这个接口来调用具体的策略实现定义的算法
- ConcreteStrategy：具体的策略实现
- Context：上下文，负责和具体的策略类交互。



##### 3. 示例代码
```java
/**
 * 策略，定义算法的接口
 */
public interface Strategy {
    /**
     * 某个算法的接口，可以有参数，也可以有返回值。这里只是示例
     */
    void algorithmInterface();
}

public class ConcreteStrategyA implements Strategy {
    @Override
    public void algorithmInterface() {
        // 具体的算法实现
    }
}

public class ConcreteStrategyB implements Strategy {
    @Override
    public void algorithmInterface() {
        // 具体的算法实现
    }
}

public class Context {
    private Strategy strategy;

    public Context(Strategy strategy) {
        this.strategy = strategy;
    }

    public void contextInterface() {
        strategy.algorithmInterface();
    }
}
```

##### 4. 策略模式的功能
策略模式的功能是把具体的算法实现从具体的业务处理中独立出来，把它们实现成为单独的算法类，从而形成一系列的算法，并让这些算法可以相互替换。

##### 5. 策略模式和if-else
每个策略算法具体实现的功能，就是原来在if-else结构中的具体实现。

多个if-else-if预计表达的就是一个平等的功能结构，要么执行if，要么执行else，或者elseif。

而策略模式就是把各个平等的具体实现封装到单独的策略实现类，通过Context来与具体的策略类进行交互。因此多个if-else语句可以考虑使用策略模式。

##### 6. 谁来选择具体的策略算法
在策略模式中，可以在两个地方来进行具体策略的选择。

一个是客户端，当使用上下文时，由客户端来选择具体的策略算法，并设置给上下文。

另一个是客户端不管，有上下文来选择具体的策略算法。

##### 7. Context的作用
如果没有上下文，策略模式就回到了最基本的接口和实现，那么需要客户端直接与具体的策略交互，尤其是当需要提供了一些公共功能，或者是相关状态存储的时候，会大大增加客户端使用难度。

有了上下文，这些工作就由上下文来完成了，客户端只要与上下文交互就可以了。

#### 三、策略模式的优缺点
###### 优点
- 避免多重条件语句：策略模式的一系列策略算法之间是平等，可以互换，写在一起就通过if-else结构来组织，如果此时具体的算法视线中又有条件语句，就构成了多重条件语句，使用策略模式能避免这样的多重条件语句。
- 具有更好的扩展性：在策略模式中扩展新的策略实现非常容易，只有增加新的策略实现类，然后再使用策略的地方选择使用这个新的策略实现就可以了。

###### 缺点
- 客户端必须了解每种策略的不同
- 增加了对象数目
- 只适合扁平的算法结构



#### 四、什么时候选用策略模式
- 出现有许多相关的类，仅仅是行为有差别的情况下，可以使用策略模式来使用多个行为中的一个来配置一个类的方法，实现算法动态切换。
- 出现同一个算法，有很多不同实现的情况下，可以使用策略模式来把这些“不同的实现”实现成为一个算法的类层次。
- 需要封装算法中与算法相关数据的情况，可以使用策略模式来避免暴露这些数据结构
- 出现抽象一个定义了很多行为的类，并且通过多个if-else语句来选择这些行为的情况下，可以使用策略模式来代替这些条件语句。



#### 五、相关模式

